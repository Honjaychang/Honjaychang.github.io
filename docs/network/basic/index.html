<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="HonjayChang Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="HonjayChang Blog Atom Feed"><title data-react-helmet="true">计网 | HonjayChang</title><meta data-react-helmet="true" property="og:url" content="https://honjaychang.github.io//docs/network/basic"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="计网 | HonjayChang"><meta data-react-helmet="true" name="description" content="HTTP状态码"><meta data-react-helmet="true" property="og:description" content="HTTP状态码"><link data-react-helmet="true" rel="shortcut icon" href="/img/photo.ico"><link data-react-helmet="true" rel="canonical" href="https://honjaychang.github.io//docs/network/basic"><link data-react-helmet="true" rel="alternate" href="https://honjaychang.github.io//docs/network/basic" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://honjaychang.github.io//docs/network/basic" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.6b743985.css">
<link rel="preload" href="/assets/js/runtime~main.a7569de2.js" as="script">
<link rel="preload" href="/assets/js/main.33694357.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a href="https://honjaychang.github.io/docs/home" target="_blank" rel="noopener noreferrer" class="navbar__brand"><img src="/img/photo.jpg" alt="My Site Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/photo.jpg" alt="My Site Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"></a><a class="navbar__item navbar__link navbar__link--active" href="/docs/Home">Docs</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Honjaychang" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button" title="Scroll to top"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/Home">Home</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">HC</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">JS</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Extension</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">TS</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">React</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">ReactCore</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Dev</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">Network</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/network/basic">计网</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Algo</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Interview</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Vue</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_1CGd"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_3E-R"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="markdown"><header><h1 class="h1Heading_27L5">计网</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http状态码"></a>HTTP<a href="HTTPs://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener noreferrer">状态码</a><a class="hash-link" href="#http状态码" title="Direct link to heading">#</a></h2><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="分类"></a>分类<a class="hash-link" href="#分类" title="Direct link to heading">#</a></h4><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息响应，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功响应，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="常见状态码"></a>常见状态码<a class="hash-link" href="#常见状态码" title="Direct link to heading">#</a></h4><ul><li>200 - 请求成功</li><li>204 - 请求处理成功，但没有资源可返回</li><li>206 - 对资源的某一部分进行请求</li><li>301 - 资源被永久转移到其它 URL(永久重定向到新的 location) Moved Permanently</li><li>302 - 资源临时移动(临时重定向) Found</li><li>303 - See Other</li><li>304 - 所请求的资源未修改</li><li>307 - 临时重定向 Temporary Redirect</li><li>308 - Permanent Redirect</li><li>400 - 请求报文存在语法错误</li><li>403 - 没有权限</li><li>404 - 请求的资源不存在</li><li>500 - 内部服务器错误</li><li>502 - 网关错误</li><li>504 - 网关超时</li></ul><blockquote><p>关于302 303 307</p></blockquote><ul><li>HTTP1.0 -&gt; 302				HTTP1.1 -&gt; 303 307</li><li>客户端发送POST请求收到302状态码，由于无法向新的URI发送重复请求（需要和用户确认），会把POST请求变为GET请求</li><li>302 允许各种各样的重定向，一般情况下都会实现为到 GET 的重定向，但是不能确保 POST 会重定向为 POST</li><li>303 只允许任意请求到 GET 的重定向</li><li>307 和 302 一样，除了不允许 POST 到 GET 的重定向</li></ul><p>308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http-method"></a>HTTP Method<a class="hash-link" href="#http-method" title="Direct link to heading">#</a></h2><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="传统的-methods"></a>传统的 methods<a class="hash-link" href="#传统的-methods" title="Direct link to heading">#</a></h4><ul><li><code>get</code> 获取服务器的数据</li><li><code>post</code> 向服务器提交数据</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="现在的-methods"></a>现在的 methods<a class="hash-link" href="#现在的-methods" title="Direct link to heading">#</a></h4><ul><li><code>get</code> 获取数据</li><li><code>post</code> 新建数据</li><li><code>patch/put</code> 更新数据</li><li><code>delete</code> 删除数据</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="restful-api"></a>Restful API<a class="hash-link" href="#restful-api" title="Direct link to heading">#</a></h4><ul><li><p>传统 API 设计:把每个 url 当做一个功能</p></li><li><p>Restful API 设计:一种新的 API 设计方法，把每个 url 当做一个唯一的资源</p></li><li><p>如何设计成一个资源？</p><ul><li>尽量不用 url 参数</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly basic"><pre tabindex="0" class="prism-code language-basic codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">传统API设计: /api/list?pageIndex=2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Restful API设计: /api/list/2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>用 method 表示操作类型</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly basic"><pre tabindex="0" class="prism-code language-basic codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">传统API设计:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">post请求  /api/create-blog</span></span><span class="token-line" style="color:#393A34"><span class="token plain">post请求  /api/update-blog?id=100</span></span><span class="token-line" style="color:#393A34"><span class="token plain">get请求   /api/get-blog?id=100</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Restful API设计:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">post请求  /api/blog</span></span><span class="token-line" style="color:#393A34"><span class="token plain">patch请求  /api/blog/100</span></span><span class="token-line" style="color:#393A34"><span class="token plain">get请求   /api/blog/100</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="get-和-post-的区别"></a>Get 和 Post 的区别？<a class="hash-link" href="#get-和-post-的区别" title="Direct link to heading">#</a></h2><ul><li>缓存：<code>get</code>请求的数据是可以缓存的；<code>post</code>是不可缓存的。</li><li>功能<ul><li><code>get</code>请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li><li><code>post</code>做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。</li></ul></li><li>传参：<code>get</code>传参，参数是在 url 中的；<code>post</code>传参，参数是在请求体中。</li><li>安全性：<code>get</code>不安全，<code>post</code>较为安全：<code>post</code>易于防止<code>CSRF</code>。</li><li>参数长度：<code>get</code>参数长度有限，是较小的；<code>post</code>传参长度不受限制。</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly js"><pre tabindex="0" class="prism-code language-js codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> params </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">URLSearchParams</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">params</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">append</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">&#x27;pid&#x27;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">123</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token operator" style="color:#393A34">?</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="get-请求传参长度的误区"></a>get 请求传参长度的误区<a class="hash-link" href="#get-请求传参长度的误区" title="Direct link to heading">#</a></h4><p><strong>误区</strong>：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p><ul><li><p><code>HTTP</code>协议未规定<code>GET</code>和<code>POST</code>的请求长度限制</p></li><li><p><code>GET</code>的最大长度显示是因为：浏览器和 web 服务器限制了 URL 的长度</p></li><li><p>不同的浏览器和 WEB 服务器，限制的最大长度不一样</p></li><li><p>要支持<code>IE</code>，则最大长度为<code>2083byte</code>，若只支持<code>Chrome</code>，则最大长度 <code>8182byte</code></p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http-首部"></a>HTTP 首部<a class="hash-link" href="#http-首部" title="Direct link to heading">#</a></h2><ul><li><code>HTTP</code> 请求报文：请求方法、<code>URI</code>、<code>HTTP</code>版本、<code>HTTP</code>首部字段</li><li><code>HTTP</code> 响应报文：<code>HTTP</code>版本、状态码、<code>HTTP</code>首部字段</li></ul><p><img src="https://cdn.jsdelivr.net/gh/honjaychang/bp/fe/20211004095902.png" alt="image-20211004095902398"></p><p><img src="https://cdn.jsdelivr.net/gh/honjaychang/bp/fe/20211004095950.png" alt="image-20211004095950303"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http首部字段"></a><code>HTTP</code>首部字段<a class="hash-link" href="#http首部字段" title="Direct link to heading">#</a></h4><ul><li>首部字段名：字段值</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="通用首部字段"></a>通用首部字段<a class="hash-link" href="#通用首部字段" title="Direct link to heading">#</a></h4><ul><li><code>Cache-Control</code> ：能够控制缓存的行为</li><li><code>Connection</code><ul><li>控制不再转发给代理的首部字段</li><li>管理持久连接 <code>Connection: Keep-Alive / close</code> 一次 TCP 连接重复使用</li></ul></li><li><code>Date</code>：表明创建 HTTP 报文的日期和时间</li><li><code>Warning</code>：会告知用户一些与缓存相关的问题的警告</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="请求首部字段"></a>请求首部字段<a class="hash-link" href="#请求首部字段" title="Direct link to heading">#</a></h4><ul><li><code>Accept</code>：告知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级<ul><li><code>Accept-Charset </code>：优先的字符集</li><li><code>Accept-Encoding</code>：可接收的压缩算法 <code>gzip</code></li><li><code>Accept-Language</code>：<code>zh-cn</code></li></ul></li><li><code>Authorization</code>：Web 认证信息</li><li><code>Host</code>：请求的域名是什么</li><li><code>User-Agent</code>：浏览器信息</li><li><code>If-Match If-Modified-Since If-None-Match If-Range</code></li><li><code>Cookie</code></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="响应首部字段"></a>响应首部字段<a class="hash-link" href="#响应首部字段" title="Direct link to heading">#</a></h4><ul><li><code>ETag</code>：资源的匹配信息</li><li><code>Location</code>：提供重定向<code>url</code></li><li><code>Server</code>：HTTP 服务器的安装信息</li><li><code>Set-Cookie</code></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="实体首部字段"></a>实体首部字段<a class="hash-link" href="#实体首部字段" title="Direct link to heading">#</a></h4><ul><li><p>包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息</p></li><li><p><code>Content-Type: text/html</code></p></li><li><p><code>Keep-Alive: timeout=15, max=100 </code></p></li><li><p><code>Allow</code>：请求资源允许使用的方法</p></li><li><p><code>Content</code></p><ul><li><code>Content-Encoding</code>：返回数据的压缩算法，如 <code>gzip</code></li><li><code>Content-Language</code></li><li><code>Content-Length</code></li><li><code>Content-Type</code>：返回 / 发送数据的格式，如<code>application/json</code></li></ul></li><li><p><code>Expires Last-Modified</code></p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="缓存相关"></a>缓存相关<a class="hash-link" href="#缓存相关" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly text"><pre tabindex="0" class="prism-code language-text codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">Cache-Control   Expires</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Last-Modified If-Modified-Since</span></span><span class="token-line" style="color:#393A34"><span class="token plain">Etag    If-None-Match</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http-缓存策略"></a>HTTP 缓存策略<a class="hash-link" href="#http-缓存策略" title="Direct link to heading">#</a></h2><p><img src="https://cdn.jsdelivr.net/gh/honjaychang/bp/fe/20211004094906.png" alt="image-20211004094906556"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="浏览器的三级缓存"></a>浏览器的三级缓存<a class="hash-link" href="#浏览器的三级缓存" title="Direct link to heading">#</a></h4><ul><li>内存 =&gt; 磁盘 =&gt; 网络请求</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="强制缓存"></a>强制缓存<a class="hash-link" href="#强制缓存" title="Direct link to heading">#</a></h4><ul><li><p>在过期时间内，未被主动清除 都不会请求服务器 而使用强制缓存 =&gt; 协商缓存</p></li><li><p><code>200 from disk cache</code> <code>200 from memory cache</code></p></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cache-control"></a><code>cache-control</code><a class="hash-link" href="#cache-control" title="Direct link to heading">#</a></h5><ul><li><code>max-age</code>：浏览器可以接收生存期不大于指定时间（秒）的响应</li><li><code>no-cache</code>：不用强制缓存，让服务端缓存</li><li><code>no-store</code>：不用强制缓存，也不让服务端缓存</li><li><code>private</code>：允许终端用户</li><li><code>public</code>：允许中间代理</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="expires"></a><code>Expires</code><a class="hash-link" href="#expires" title="Direct link to heading">#</a></h5><ul><li>同为控制缓存过期。如果 <code>cache-control</code> 与 <code>expires</code> 同时存在的话，<code>cache-control</code> 的优先级高于<code>expires</code></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="协商缓存对比缓存"></a>协商缓存（对比缓存）<a class="hash-link" href="#协商缓存对比缓存" title="Direct link to heading">#</a></h4><ul><li>浏览器和服务器协商，每次都需要和服务器通信</li><li>第一次请求时，服务器会返回资源和一个资源的缓存标识</li><li>第二次请求时，浏览器会先将缓存标识发给服务器 然后服务器对标识进行匹配<ul><li>不匹配 =&gt; 资源有更新 =&gt; 服务器返回新资源和新的缓存标识</li><li>匹配 =&gt; 资源未更改 =&gt; 返回 304 状态码 读取本地浏览器缓存</li></ul></li></ul><blockquote><p><code>200 from cache</code> <code>304 Not Modified</code></p></blockquote><ul><li><code>200 OK from cache</code> 不向服务器发送请求，直接使用本地缓存文件</li><li><code>304 Not Modified</code> 则向服务器询问，若服务器认为浏览器的缓存版本还可用，那么便会返回304</li></ul><blockquote><p>服务端如何判断缓存失效</p></blockquote><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="last-modified"></a><code>Last-Modified</code><a class="hash-link" href="#last-modified" title="Direct link to heading">#</a></h5><ul><li><code>Last-Modified</code> 响应资源的最后修改时间	对应 <code>If-Modified-Since</code></li><li>只能精确到秒级		配合 <code>cache-control</code> 使用</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="etag"></a><code>Etag</code><a class="hash-link" href="#etag" title="Direct link to heading">#</a></h5><ul><li><code>Etag</code>是服务器响应请求时，返回当前资源文件的一个唯一标识(类似指纹 由服务器生成)		对应 <code>If-None-Match</code></li><li>同时存在 会优先使用 <code>Etag</code></li></ul><p>主要解决<code>Last-Modified</code> 存在的问题</p><ul><li><code>Last-Modified</code> 只能精确到秒级，如果1秒内被多次修改无法获取精确时间</li><li>文件定期生成，但文件内容不变，会导致<code>Last-Modified</code>变化，而无法使用缓存  此时使用 <code>Etag</code> 会更合适</li><li>服务器时间不一致的情况</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="浏览器加载js文件有缓存"></a>浏览器加载<code>JS</code>文件有缓存<a class="hash-link" href="#浏览器加载js文件有缓存" title="Direct link to heading">#</a></h5><ul><li>浏览器加载 js 文件是根据路径加载，首先根据路径在缓存里查找</li><li>解决办法：打包时加一些哈希值 or 版本号</li></ul><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>Ref</h5></div><div class="admonition-content"><ul><li><a href="https://blog.csdn.net/i13738612458/article/details/80383390?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control" target="_blank" rel="noopener noreferrer">js 浏览器缓存机制</a></li><li><a href="https://blog.csdn.net/feiyu_may/article/details/88376945" target="_blank" rel="noopener noreferrer">浏览器缓存带来的前端项目更新问题及解决方法</a></li></ul></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="刷新操作对缓存的影响"></a>刷新操作对缓存的影响<a class="hash-link" href="#刷新操作对缓存的影响" title="Direct link to heading">#</a></h5><ul><li>正常操作:<ul><li>地址栏输入<code>url</code>，跳转链接，前进后退等</li><li>强制缓存有效，协商缓存有效</li></ul></li><li>手动刷新:<ul><li><code>F5</code>，点击刷新按钮，右击菜单刷新</li><li>强制缓存失效，协商缓存有效</li></ul></li><li>强制刷新:<ul><li><code>ctrl + F5</code></li><li>强制缓存失效，协商缓存失效</li></ul></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="不能被缓存的请求"></a>不能被缓存的请求<a class="hash-link" href="#不能被缓存的请求" title="Direct link to heading">#</a></h5><ul><li>HTTP信息头中包含<code>Cache-Control:no-cache | max-age = 0</code>，等告诉浏览器不用缓存的请求</li><li>需要根据<code>Cookie</code>，认证信息等决定输入内容的动态请求是不能被缓存的</li><li>经过<code>HTTPS</code>安全加密的请求</li><li>POST请求无法被缓存</li><li>HTTP响应头中不包含<code>Last-Modified/Etag</code>，也不包含<code>Cache-Control/Expires</code>的请求无法被缓存</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tcp-和-udp-的区别"></a>TCP 和 UDP 的区别<a class="hash-link" href="#tcp-和-udp-的区别" title="Direct link to heading">#</a></h2><ul><li>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议</li><li></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="连接方面"></a>连接方面<a class="hash-link" href="#连接方面" title="Direct link to heading">#</a></h5><ul><li>TCP 面向连接，UDP 不需要连接</li><li>TCP 需要三次握手四次挥手请求连接 <a href="https://segmentfault.com/a/1190000018592072" target="_blank" rel="noopener noreferrer">TCP 是如何实现可靠连接的？</a><ul><li>超时重传</li></ul></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="可靠性"></a>可靠性<a class="hash-link" href="#可靠性" title="Direct link to heading">#</a></h5><ul><li>TCP 是可靠传输；一旦传输过程中丢包的话会进行重传</li><li>UDP 是不可靠传输，但会最大努力交付</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="工作效率"></a>工作效率<a class="hash-link" href="#工作效率" title="Direct link to heading">#</a></h5><ul><li>UDP 实时性高，比 TCP 工作效率高</li><li>因为不需要建立连接，更不需要复杂的握手挥手以及复杂的算法，也没有 4 重传机制</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="是否支持多对多"></a>是否支持多对多<a class="hash-link" href="#是否支持多对多" title="Direct link to heading">#</a></h5><ul><li>TCP 是点对点的</li><li>UDP 支持一对一，一对多，多对多</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="首部大小"></a>首部大小<a class="hash-link" href="#首部大小" title="Direct link to heading">#</a></h5><ul><li>TCP 首部占 20 字节</li><li>UDP 首部占 8 字节，首部开销小。同样的报文内容，UDP 会比 TCP 更高效。</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="拥塞控制流量控制"></a>拥塞控制、流量控制<a class="hash-link" href="#拥塞控制流量控制" title="Direct link to heading">#</a></h5><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="三次握手四次挥手"></a>三次握手四次挥手<a class="hash-link" href="#三次握手四次挥手" title="Direct link to heading">#</a></h2><ul><li><code>SYN(Synchronize) 同步</code> <code>ACK 确认</code></li><li><code>ACK</code>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><code>FIN</code>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="三次握手"></a>三次握手<a class="hash-link" href="#三次握手" title="Direct link to heading">#</a></h5><p><img src="https://cdn.jsdelivr.net/gh/honjaychang/bp/fe/threeHands.png" alt="三次握手"></p><p><img src="https://cdn.jsdelivr.net/gh/honjaychang/bp/fe/20211005085952.png" alt="图片"></p><p><strong>实质</strong>：客户端连接服务器指定端口 建立 TCP 连接，并同步双方的序列号和确认号，交换<code>TCP窗口大小</code>信息</p><ul><li>服务端调用<code>listen</code>系统命令，进入监听状态，等待客户端的连接。</li><li>客户端向服务端发送<code>连接请求报文</code>。客户端会随机初始化「序号」<code>x</code>，并将中<code>SYN</code> 标志位置为<code>1</code>，发送<code>SYN</code>报文。  <code>SYN=1 seq=x</code></li><li>服务端收到请求报文，向 客户端 发送 <code>连接确认报文</code> 。服务端也随机初始化自己的「序号」<code> y</code> ，其次将TCP首部的「确认应答号」字段填入 <code>x+1</code>，接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。  <code>SYN=1 ACk=1 seq=y ack=x+1</code></li><li>客户端 收到 服务端的连接确认报文后，还要向 服务端 <code>发出确认</code>，「确认应答号」为 <code>y+1</code>，「序号」为 <code>x+1</code>。  <code>ACK=1 seq=x+1 ack=y+1</code></li><li>服务端 收到 客户端 的确认后，<code>连接建立</code></li></ul><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p><blockquote><p>为什么三次</p></blockquote><ul><li><p>三次握手才可以阻止历史重复连接的初始化（主要原因）</p></li><li><p>三次握手才可以同步双方的初始序列号</p></li><li><p>三次握手才可以避免资源浪费 （SYN泛洪？</p></li><li><p>第一次握手：客户端发送网络包，服务端收到了。
服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p></li><li><p>第二次握手：服务端发包，客户端收到了。
客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p></li><li><p>第三次握手：客户端发包，服务端收到了。
服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</p></li><li><p>因此，需要三次握手才能确认双方的接收与发送能力是否正常</p></li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="四次挥手"></a>四次挥手<a class="hash-link" href="#四次挥手" title="Direct link to heading">#</a></h5><p><img src="https://cdn.jsdelivr.net/gh/honjaychang/bp/fe/fourHands.png" alt="四次挥手"></p><ul><li>当主动方关闭连接时，会发送 <code>FIN</code> 报文，此时主动方的连接状态由 <code>ESTABLISHED</code> 变为 <code>FIN_WAIT1</code>。当被动方收到 <code>FIN</code> 报文后，内核自动回复 <code>ACK</code> 报文，连接状态由 <code>ESTABLISHED</code> 变为 <code>CLOSE_WAIT</code>，顾名思义，它在等待进程调用 <code>close</code> 函数关闭连接。当主动方接收到这个 <code>ACK</code> 报文后，连接状态由 <code>FIN_WAIT1</code> 变为 <code>FIN_WAIT2</code>，主动方的发送通道就关闭了。</li><li>再来看被动方的发送通道是如何关闭的。当被动方进入 <code>CLOSE_WAIT</code> 状态时，进程的 <code>read</code> 函数会返回 0，这样开发人员就会有针对性地调用 <code>close 函数</code>，进而触发内核发送 <code>FIN</code> 报文，此时被动方连接的状态变为 <code>LAST_ACK</code>。当主动方收到这个 <code>FIN</code> 报文时，内核会自动回复 <code>ACK</code>，同时连接的状态由 <code>FIN_WAIT2</code> 变为 <code>TIME_WAIT</code>，<code>Linux</code> 系统下大约 <code>1 分钟</code>后 TIME_WAIT 状态的连接才会彻底关闭。而被动方收到 <code>ACK</code> 报文后，连接就会关闭。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/honjaychang/bp/fe/20211005090014.png" alt="图片"></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><blockquote><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong></p></blockquote><blockquote><p>为什么需要三次握手，四次挥手呢？</p></blockquote><ul><li>3次握手的作用就是双方都能明确自己和对方的收、发能力是正常的，三次连接是保证可靠性的最小握手次数。</li><li>4次挥手呐，TCP的全双工通信断开连接，需要双方的都确认断开。当客户端确认自己没有数据要传给服务器时，并不能保证服务器也没有数据要发送了。前两次挥手是客户端和服务器对连接断开的确认，第三次服务器会将剩下的数据发给客户端。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tcp拓展"></a>TCP拓展<a class="hash-link" href="#tcp拓展" title="Direct link to heading">#</a></h2><ul><li>粘包</li><li>TCP可靠传输：超时重传</li><li>TCP滑动窗口：控制字节流存放大小？</li><li>TCP流量控制：控制发送方发送速率，保证接收方来得及</li><li>TCP拥塞控制：网络拥塞时，控制重传速率</li></ul><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>Ref</h5></div><div class="admonition-content"><ul><li>图源：博客 <a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener noreferrer">两张动图-彻底明白 TCP 的三次握手与四次挥手</a></li><li><a href="https://yuanrengu.com/2020/77eef79f.html" target="_blank" rel="noopener noreferrer">面试官，不要再问我三次握手和四次挥手</a></li><li><a href="https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw" target="_blank" rel="noopener noreferrer">硬不硬你说了算！近 40 张图解被问千百遍的 TCP 三次握手和四次挥手面试题</a></li><li><a href="https://zhuanlan.zhihu.com/p/108822858" target="_blank" rel="noopener noreferrer">一文搞定 UDP 和 TCP 高频面试题！</a></li></ul></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="osi-七层模型"></a>OSI 七层模型<a class="hash-link" href="#osi-七层模型" title="Direct link to heading">#</a></h2><ul><li>TCP 属于传输层</li><li>发送数据是封装过程 接收则是解封装</li></ul><p><img src="HTTPs://cdn.jsdelivr.net/gh/honjaychang/bp/fe/osiModel.png" alt="OSI 七层模型"></p><ul><li>物理层：利用物理传输介质为数据链路层提供物理连接，实现比特流的透明传输</li><li>数据链路层：<ul><li>交换机 帧（帧是放置数据的、逻辑的、结构化的包</li><li>将来自物理层的原始数据进行 MAC 地址的封装与解封装</li><li>点到点传输</li></ul></li><li>网络层：<ul><li>ARP：地址解析协议</li><li>路由器 数据包分组</li><li>将数据链路层的数据进行 IP 地址的封装与解封装</li><li>IP 地址寻址问题 路由算法：确定从源结点沿着网络到目的结点的路由选择</li><li>数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信</li></ul></li><li>传输层：<ul><li>定义传输数据的协议和端口 TCP UDP</li><li>将从下层接收的数据进行分段和传输，到达目的地址后再进行重组</li><li>向用户提供可靠的、透明的、端到端的数据传输，以及差错控制和流量控制机制</li><li><a href="https://blog.csdn.net/weixin_43914604/article/details/105531547?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener noreferrer">TCP 流量控制</a></li></ul></li><li>会话层：<ul><li>会话层建立、管理和终止应用程序进程之间的会话和数据交换</li></ul></li><li>表示层<ul><li>主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等</li></ul></li><li>应用层<ul><li>终端应用</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="https--http"></a>HTTPS &amp; HTTP<a class="hash-link" href="#https--http" title="Direct link to heading">#</a></h2><p>HTTP：无状态<code>(stateless)</code>协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。即协议对于发送过的请求或响应都不做持久化处理</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="区别"></a>区别<a class="hash-link" href="#区别" title="Direct link to heading">#</a></h4><ul><li><code>HTTP</code>：无状态无连接，而且是明文传输，不安全 80</li><li><code>HTTPS</code>：传输内容加密，身份验证，保证数据完整性 <code>HTTP + SSL/TLS</code> 443   在HTTP 与 TCP层之间加入了 <code>SSL/TLS</code> 协议</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http-的不足"></a>HTTP 的不足<a class="hash-link" href="#http-的不足" title="Direct link to heading">#</a></h5><ul><li>通信使用明文，内容可能会被窃听 -&gt; 通信加密 <del>数据加密</del></li><li>不验证通信方的身份，因此有可能遭遇伪装 -&gt; <code>SSL HTTPS</code> 数字证书</li><li>无法证明报文的完整性，所以有可能已遭篡改 -&gt; 中间人攻击 MD5 数字签名</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="数字证书"></a>数字证书<a class="hash-link" href="#数字证书" title="Direct link to heading">#</a></h5><ul><li>解决通信身份可能被伪装问题</li><li>服务器运营人员向第三方证书机构提交 CA 公钥、组织信息、域名等信息进行申请认证</li><li>数字证书机构通过线上线下等手段去验证所提供的信息是否合法。合法的话会向申请者颁发证书（包含 CA 公钥、证书机构和所有者组织信息、证书有效时间、序列号等信息，还包含一个签名（使用散列函数计算公开明文的消息摘要并通过 CA 的私钥进行加密 =&gt; 签名</li><li>客户端向目标服务器发起请求时会返回相应的证书文件</li><li>客户端读取证书中信息，进行相同的散列函数计算得到消息摘要。通过 CA 中的公钥解密签名数据，对比证书的消息摘要是否一致来判断是否合法</li></ul><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="完整性检测---数字签名"></a>完整性检测 - 数字签名<a class="hash-link" href="#完整性检测---数字签名" title="Direct link to heading">#</a></h5><ul><li>将一段文本通过<code>hash</code>函数生成消息摘要，再通过客户端的私钥进行加密生成数字签名</li><li>服务器收到数字签名后先用公钥进行解密 得到消息摘要<ul><li>然后对收到的原文也进行<code>hash</code>生成消息摘要</li><li>比较前后两次消息摘要 如果相同 则证明完整没有被篡改</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="https-实现原理"></a>HTTPS 实现原理<a class="hash-link" href="#https-实现原理" title="Direct link to heading">#</a></h4><p><strong>HTTP +</strong> 加密 <strong>+</strong> 认证 <strong>+</strong> 完整性保护 = <strong>HTTPS</strong></p><ul><li><p>过程</p><ul><li>客户端发送消息给服务器（包含可用的加密算法和压缩算法</li><li>服务器返回消息给客户端（包含选用的加密和压缩算法以及数字证书认证机构 CA 签发的证书（包含公钥 + 证书所应用的域名范围</li><li>客户端去验证公钥证书 是否合法</li><li>客户端使用伪随机数生成传输信息所用的对称密钥，然后通过证书的公钥去传输对称密钥</li><li>服务端接收到信息后，用自己的私钥去解密来获得对称密钥</li><li>服务端使用对称密钥与客户端进行通信（此时双方都已经拥有了对称密钥</li></ul></li><li><p>SSL 公钥加密的算法</p><ul><li>对称加密的问题：密钥分发的问题 安全性问题</li></ul></li><li><p>HTTPS 采用 共享密钥(对称加密) 和 公开密钥(非对称加密)两者混用的加密机制</p><ul><li>非对称：交换对称密钥。通信建立前</li><li>对称：信息交换。通信过程中</li></ul></li></ul><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>Ref</h5></div><div class="admonition-content"><ul><li><a href="https://juejin.cn/post/6844903830916694030" target="_blank" rel="noopener noreferrer">深入理解 HTTPS 工作原理</a></li><li><a href="https://cloud.tencent.com/developer/article/1005197" target="_blank" rel="noopener noreferrer">深入浅出 HTTPS 工作原理</a></li></ul></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http-版本"></a>HTTP 版本<a class="hash-link" href="#http-版本" title="Direct link to heading">#</a></h4><ul><li>HTTP/0.9：只能进行<code>get</code>请求，发送纯文本</li><li>HTTP/1.0：添加了<code>POST、HEAD、OPTION、PUT、DELETE</code>等</li><li>HTTP/1.1：<ul><li>默认支持了长连接<code>keep-alive</code>：旨在建立 <strong>1</strong> 次 <strong>TCP</strong> 连接后进行多次请求和响应的交互 <code>Keep-Alive: timeout=5, max=100</code></li><li>管线化：不用等待响应亦可直接发送下一个请求，就能够做到同时并行发送多个请求</li><li>虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 <code>Cookie</code> 技术（通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态</li><li>增加了<code>host</code> 域，而且节约带宽?</li></ul></li><li>HTTP/2：<ul><li>多路复用：让所有的通信都在一个 TCP 连接上完成，实现了请求的并发</li><li>头部压缩：利用 HPACK 算法压缩头部的<code>User-Agent Cookie Accept Server Rabge</code>等字段</li><li>服务器推送：使得服务器可以预测客户端需要的资源，主动推送到客户端</li></ul></li></ul><blockquote><p>关于HTTP的队头阻塞问题</p></blockquote><ul><li><code>HTTP/1.0</code> 每次请求都会建立一个TCP连接  请求结束后立即断开连接</li><li><code>HTTP/1.1</code> 每一个连接都是长连接。对于同一个TCP连接可以发送多个<code>HTTP/1.1</code> 请求。<ul><li>不必等前一个返回就可以发送下一个 --&gt; 解决了<code>HTTP/1.0</code> 中客户端的队头阻塞 --&gt; <code>Pipline</code></li><li>但是<code>HTTP/1.1</code> 要求服务端返回响应 按照请求发送顺序返回 --&gt; <code>1.0</code> 的服务端的队头阻塞</li></ul></li><li><code>HTTP/2.0</code> <ul><li>二进制封帧<ul><li>在 <code>HTTP/1.1</code>数据包是文本格式的， 而 <code>HTTP/2</code> 的数据包是二进制格式</li><li>采用帧的传输方式可以将请求和响应的数据分割的更小</li></ul></li><li>多路复用<ul><li>HTTP/1.1 并发多个请求需要多个TCP链接，且单个域名有6-8个TCP链接请求限制</li><li>同一域名下所有通信在单个TCP链接下完成，且这个链接可以并行请求和响应 互不干扰</li></ul></li></ul></li></ul><blockquote><p>使用长连接之后，客户端、服务端怎么知道本次传输结束呢？</p></blockquote><ul><li>判断传输数据是否达到了<code>Content-Length</code> 指示的大小</li><li>动态生成的文件没有 <code>Content-Length</code> ，它是分块传输<code>chunked</code>，这时候就要根据 <code>chunked</code> 编码来判断，<code>chunked</code> 编码的数据在最后有一个空 <code>chunked</code> 块，表明本次传输数据结束</li></ul><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>Ref</h5></div><div class="admonition-content"><ul><li><a href="https://g.yuque.com/kougazhang/network/ccyd8g" target="_blank" rel="noopener noreferrer">简介: http/https/http2</a></li><li><a href="https://blog.51cto.com/12118369/1962662" target="_blank" rel="noopener noreferrer">http1.0，http1.1 和 http2.0 的区别</a></li></ul></div></div><p><code>cookie</code> 是存储在浏览器的小段文本，会在浏览器每次向同一服务器再发起请求时被携带并发送到服务 器上。我们可以把状态信息放在<code>cookie</code>里，带给服务器。</p><p><code>session</code> 是存储在服务器的用户数据。浏览器第一次向服务器发起请求时，服务器会为当前会话创建一个 <code>session</code>，并且把对应的 <code>session-id</code> 写入 <code>cookie</code> 中，用来标识 <code>session</code>。此后，每次用户的请求都会携带 一个包含了 <code>session-id</code> 的 <code>cookie</code>，服务器解析出了 <code>session-id</code>，便能定位到用户的用户信息。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="浏览器输入网址到页面渲染全过程"></a>浏览器输入网址到页面渲染全过程<a class="hash-link" href="#浏览器输入网址到页面渲染全过程" title="Direct link to heading">#</a></h2><p><img src="https://cdn.jsdelivr.net/gh/honjaychang/bp/fe/dns.png" alt="DNS域名解析过程1"></p><ul><li>DNS 解析：域名解析为 IP 地址<ul><li>缓存命中：浏览器缓存 =&gt; 操作系统缓存 =&gt; <code>LDNS</code> 本地区域名服务器缓存（学校机房 / <code>ISP</code>）</li><li><code>LDNS</code> =&gt; 根域名服务器   根域名服务器返回给 <code>LDNS</code> 一个所查询的主域名服务器 <code>gTLD</code> 地址</li><li><code>LDNS</code> =&gt; <code>gTLD</code> 发起请求   返回域名对应的 <code>Name Server</code> 域名服务器地址</li><li><code>LDNS</code> =&gt; <code>Name Server</code> 查询请求域名的对应IP地址  返回对应IP以及TTL</li><li><code>LDNS</code> 根据返回的TTL对IP进行缓存 并将结果返回给用户</li><li><code>TTL: time to live</code> 域名缓存的最长时间</li></ul></li><li>TCP 连接：三次握手</li><li>发送 HTTP 请求</li><li>服务器处理请求 并 返回 HTTP 响应报文</li></ul><ul><li>浏览器解析渲染页面：<code>HTML、CSS、JS</code>文件</li><li><code>DOM Tree + CSSOM =&gt; Render Tree =&gt; JS =&gt; Render Tree</code></li><li>连接结束</li></ul><div class="admonition admonition-note alert alert--secondary"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>Ref</h5></div><div class="admonition-content"><ul><li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener noreferrer">前端经典面试题: 从输入 URL 到页面加载发生了什么？</a></li><li><a href="https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/" target="_blank" rel="noopener noreferrer">经典面试题：从 URL 输入到页面展现到底发生什么？</a></li><li><a href="https://www.cnblogs.com/xrq730/p/4931418.html" target="_blank" rel="noopener noreferrer">五月的仓颉 DNS域名解析过程</a></li></ul></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/dev/webpack"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« WebPack</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/ds/basic"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">数据结构 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#http状态码" class="table-of-contents__link">HTTP状态码</a></li><li><a href="#http-method" class="table-of-contents__link">HTTP Method</a></li><li><a href="#get-和-post-的区别" class="table-of-contents__link">Get 和 Post 的区别？</a></li><li><a href="#http-首部" class="table-of-contents__link">HTTP 首部</a></li><li><a href="#http-缓存策略" class="table-of-contents__link">HTTP 缓存策略</a></li><li><a href="#tcp-和-udp-的区别" class="table-of-contents__link">TCP 和 UDP 的区别</a></li><li><a href="#三次握手四次挥手" class="table-of-contents__link">三次握手四次挥手</a></li><li><a href="#tcp拓展" class="table-of-contents__link">TCP拓展</a></li><li><a href="#osi-七层模型" class="table-of-contents__link">OSI 七层模型</a></li><li><a href="#https--http" class="table-of-contents__link">HTTPS &amp; HTTP</a></li><li><a href="#浏览器输入网址到页面渲染全过程" class="table-of-contents__link">浏览器输入网址到页面渲染全过程</a></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.a7569de2.js"></script>
<script src="/assets/js/main.33694357.js"></script>
</body>
</html>